<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAML Browser Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: #2d2d30;
            padding: 16px 24px;
            border-bottom: 1px solid #3e3e42;
        }
        
        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
        }
        
        .header p {
            font-size: 13px;
            color: #858585;
            margin-top: 4px;
        }
        
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #3e3e42;
        }
        
        .panel-header {
            background: #252526;
            padding: 12px 16px;
            font-size: 13px;
            font-weight: 600;
            border-bottom: 1px solid #3e3e42;
        }
        
        .editor {
            flex: 1;
            padding: 16px;
            background: #1e1e1e;
            overflow: auto;
        }
        
        textarea {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
        }
        
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #252526;
        }
        
        .preview {
            flex: 1;
            padding: 24px;
            overflow: auto;
            background: #2d2d30;
        }
        
        .render-container {
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: inline-block;
            min-width: 200px;
        }
        
        .error-message {
            background: #5a1d1d;
            border: 1px solid #be1100;
            border-radius: 4px;
            padding: 16px;
            color: #f48771;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .controls {
            padding: 12px 16px;
            background: #252526;
            border-top: 1px solid #3e3e42;
            display: flex;
            gap: 12px;
        }
        
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #1177bb;
        }
        
        button:active {
            background: #0d5a8f;
        }
        
        /* Avalonia-like default styles */
        .avalonia-border {
            border: 1px solid #ccc;
            display: inline-block;
        }
        
        .avalonia-stackpanel {
            display: flex;
            flex-direction: column;
        }
        
        .avalonia-textblock {
            color: #000;
            font-family: 'Segoe UI', sans-serif;
        }
        
        .avalonia-button {
            background: #e1e1e1;
            border: 1px solid #adadad;
            padding: 6px 12px;
            cursor: pointer;
            font-family: 'Segoe UI', sans-serif;
        }
        
        .avalonia-button:hover {
            background: #bee6fd;
            border-color: #3c7fb1;
        }
        
        .avalonia-textbox {
            border: 1px solid #acacac;
            padding: 4px 8px;
            background: white;
            font-family: 'Segoe UI', sans-serif;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>⚡ XAML Browser Viewer</h1>
        <p>Live Avalonia XAML Preview - Architected with OOP & SOLID Principles</p>
    </div>
    
    <div class="container">
        <div class="editor-panel">
            <div class="panel-header">XAML Editor</div>
            <div class="editor">
                <textarea id="xamlInput" spellcheck="false">
<Border Background="#2D2D30" 
        BorderBrush="#3E3E42" 
        BorderThickness="2"
        Padding="16">
  <StackPanel Spacing="12">
    <TextBlock Text="Hello from XAML!" 
               FontSize="18" 
               FontWeight="Bold"/>
    <TextBlock Text="This is rendering in your browser!" 
               FontSize="14"
               Opacity="0.8"/>
    <Button Content="Click Me!" 
            Padding="8,4"/>
  </StackPanel>
</Border>
                </textarea>
            </div>
        </div>
        
        <div class="preview-panel">
            <div class="panel-header">Live Preview</div>
            <div class="preview" id="preview">
                <div class="render-container" id="renderContainer"></div>
            </div>
            <div class="controls">
                <button onclick="viewer.render()">🔄 Render</button>
                <button onclick="viewer.autoRender()">⚡ Auto-Render (On Type)</button>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 🏛️ ARCHITECTURE: OOP & SOLID PRINCIPLES
        // ==========================================
        
        /**
         * Base class for all XAML elements
         * SRP: Single Responsibility - Base rendering logic
         */
        class XamlElement {
            constructor(tagName, attributes = {}, children = []) {
                this.tagName = tagName;
                this.attributes = attributes;
                this.children = children;
            }
            
            /**
             * Template method pattern - subclasses override
             */
            render() {
                const element = this.createElement();
                this.applyAttributes(element);
                this.renderChildren(element);
                return element;
            }
            
            createElement() {
                return document.createElement('div');
            }
            
            applyAttributes(element) {
                // Apply common attributes
                if (this.attributes.Background) {
                    element.style.background = this.attributes.Background;
                }
                if (this.attributes.Padding) {
                    element.style.padding = this.parseThickness(this.attributes.Padding);
                }
                if (this.attributes.Margin) {
                    element.style.margin = this.parseThickness(this.attributes.Margin);
                }
            }
            
            renderChildren(element) {
                this.children.forEach(child => {
                    if (typeof child === 'string') {
                        element.appendChild(document.createTextNode(child));
                    } else {
                        element.appendChild(child.render());
                    }
                });
            }
            
            parseThickness(value) {
                const parts = value.split(',').map(p => p.trim() + 'px');
                if (parts.length === 1) return parts[0];
                if (parts.length === 2) return `${parts[0]} ${parts[1]}`;
                if (parts.length === 4) return `${parts[0]} ${parts[1]} ${parts[2]} ${parts[3]}`;
                return value;
            }
        }
        
        /**
         * Border element
         * SRP: Handle border-specific rendering
         */
        class BorderElement extends XamlElement {
            createElement() {
                const div = document.createElement('div');
                div.className = 'avalonia-border';
                return div;
            }
            
            applyAttributes(element) {
                super.applyAttributes(element);
                
                if (this.attributes.BorderBrush) {
                    element.style.borderColor = this.attributes.BorderBrush;
                }
                if (this.attributes.BorderThickness) {
                    element.style.borderWidth = this.parseThickness(this.attributes.BorderThickness);
                    element.style.borderStyle = 'solid';
                }
            }
        }
        
        /**
         * StackPanel element
         * SRP: Handle layout-specific rendering
         */
        class StackPanelElement extends XamlElement {
            createElement() {
                const div = document.createElement('div');
                div.className = 'avalonia-stackpanel';
                div.style.display = 'flex';
                return div;
            }
            
            applyAttributes(element) {
                super.applyAttributes(element);
                
                const orientation = this.attributes.Orientation || 'Vertical';
                element.style.flexDirection = orientation === 'Horizontal' ? 'row' : 'column';
                
                if (this.attributes.Spacing) {
                    element.style.gap = this.attributes.Spacing + 'px';
                }
            }
        }
        
        /**
         * TextBlock element
         * SRP: Handle text rendering
         */
        class TextBlockElement extends XamlElement {
            createElement() {
                const span = document.createElement('span');
                span.className = 'avalonia-textblock';
                return span;
            }
            
            applyAttributes(element) {
                super.applyAttributes(element);
                
                if (this.attributes.Text) {
                    element.textContent = this.attributes.Text;
                }
                if (this.attributes.FontSize) {
                    element.style.fontSize = this.attributes.FontSize + 'px';
                }
                if (this.attributes.FontWeight) {
                    element.style.fontWeight = this.attributes.FontWeight.toLowerCase();
                }
                if (this.attributes.Opacity) {
                    element.style.opacity = this.attributes.Opacity;
                }
            }
        }
        
        /**
         * Button element
         * SRP: Handle button rendering
         */
        class ButtonElement extends XamlElement {
            createElement() {
                const button = document.createElement('button');
                button.className = 'avalonia-button';
                return button;
            }
            
            applyAttributes(element) {
                super.applyAttributes(element);
                
                if (this.attributes.Content) {
                    element.textContent = this.attributes.Content;
                }
            }
        }
        
        /**
         * XAML Parser
         * SRP: Parse XAML string to element tree
         * SoC: Separated from rendering logic
         */
        class XamlParser {
            parse(xamlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xamlString, 'text/xml');
                
                // Check for parsing errors
                const parserError = doc.querySelector('parsererror');
                if (parserError) {
                    throw new Error('Invalid XAML: ' + parserError.textContent);
                }
                
                return this.parseElement(doc.documentElement);
            }
            
            parseElement(xmlNode) {
                const tagName = xmlNode.tagName;
                const attributes = this.parseAttributes(xmlNode);
                const children = this.parseChildren(xmlNode);
                
                // Factory pattern - create appropriate element type
                return this.createElement(tagName, attributes, children);
            }
            
            parseAttributes(xmlNode) {
                const attributes = {};
                for (let attr of xmlNode.attributes) {
                    attributes[attr.name] = attr.value;
                }
                return attributes;
            }
            
            parseChildren(xmlNode) {
                const children = [];
                for (let child of xmlNode.childNodes) {
                    if (child.nodeType === Node.ELEMENT_NODE) {
                        children.push(this.parseElement(child));
                    } else if (child.nodeType === Node.TEXT_NODE) {
                        const text = child.textContent.trim();
                        if (text) children.push(text);
                    }
                }
                return children;
            }
            
            createElement(tagName, attributes, children) {
                // Factory method - extensible for new element types
                switch (tagName) {
                    case 'Border': return new BorderElement(tagName, attributes, children);
                    case 'StackPanel': return new StackPanelElement(tagName, attributes, children);
                    case 'TextBlock': return new TextBlockElement(tagName, attributes, children);
                    case 'Button': return new ButtonElement(tagName, attributes, children);
                    default: return new XamlElement(tagName, attributes, children);
                }
            }
        }
        
        /**
         * XAML Renderer
         * SRP: Coordinate parsing and rendering
         * SoC: Separated from UI concerns
         */
        class XamlRenderer {
            constructor(parser) {
                this.parser = parser;
            }
            
            render(xamlString) {
                try {
                    const rootElement = this.parser.parse(xamlString);
                    return {
                        success: true,
                        element: rootElement.render()
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
        }
        
        /**
         * XAML Viewer Application
         * SRP: Orchestrate UI and rendering
         * The Guardian: Error handling, user feedback
         */
        class XamlViewer {
            constructor() {
                this.parser = new XamlParser();
                this.renderer = new XamlRenderer(this.parser);
                this.autoRenderEnabled = false;
                this.autoRenderTimeout = null;
                
                this.initializeUI();
            }
            
            initializeUI() {
                this.input = document.getElementById('xamlInput');
                this.container = document.getElementById('renderContainer');
                
                // Initial render
                this.render();
            }
            
            render() {
                const xaml = this.input.value;
                const result = this.renderer.render(xaml);
                
                this.container.innerHTML = '';
                
                if (result.success) {
                    this.container.appendChild(result.element);
                } else {
                    this.showError(result.error);
                }
            }
            
            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = '❌ Error: ' + message;
                this.container.appendChild(errorDiv);
            }
            
            autoRender() {
                this.autoRenderEnabled = !this.autoRenderEnabled;
                
                if (this.autoRenderEnabled) {
                    this.input.addEventListener('input', this.handleInput.bind(this));
                    alert('✅ Auto-render enabled! Type to see live updates.');
                } else {
                    this.input.removeEventListener('input', this.handleInput.bind(this));
                    alert('⏸️ Auto-render disabled.');
                }
            }
            
            handleInput() {
                clearTimeout(this.autoRenderTimeout);
                this.autoRenderTimeout = setTimeout(() => {
                    this.render();
                }, 500); // Debounce 500ms
            }
        }
        
        // ==========================================
        // 🚀 APPLICATION INITIALIZATION
        // ==========================================
        
        const viewer = new XamlViewer();
    </script>
</body>
</html>
